<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Writer</title>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/daisyui@5" rel="stylesheet" type="text/css" />    
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body { height: 100dvh; }
        .tab-active {
            background-color: #93b9f5;
            color: white;
        }
        /* Dirty (unsaved) tab visual */
        .tab-dirty {
            background-color: #fde68a; /* amber-200 */
            color: #78350f; /* amber-900 */
        }
        /* Simple context menu styling */
        #context-menu {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb; /* gray-200 */
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            border-radius: 0.25rem;
            z-index: 1000;
            width: 160px;
        }
        #context-menu.hidden { display: none; }
        #context-menu .item { padding: 8px 12px; cursor: pointer; }
        #context-menu .item:hover { background: #f3f4f6; }

        /* Active file in tree */
        .active-file { background-color: #dbeafe; /* blue-100 */ }

        /* Basic markdown preview typography without relying on plugins */
        #preview { line-height: 1.7; }
        #preview h1 { font-size: 2rem; font-weight: 700; margin: 1.25em 0 0.6em; }
        #preview h2 { font-size: 1.75rem; font-weight: 700; margin: 1.2em 0 0.55em; }
        #preview h3 { font-size: 1.5rem; font-weight: 600; margin: 1.1em 0 0.5em; }
        #preview h4 { font-size: 1.25rem; font-weight: 600; margin: 1em 0 0.5em; }
        #preview h5 { font-size: 1.125rem; font-weight: 600; margin: 0.9em 0 0.5em; }
        #preview h6 { font-size: 1rem; font-weight: 600; margin: 0.8em 0 0.5em; text-transform: uppercase; letter-spacing: .02em; }
        #preview p, #preview ul, #preview ol { margin: 0.75em 0; }
        #preview ul { list-style: disc; padding-left: 1.5rem; }
        #preview ol { list-style: decimal; padding-left: 1.5rem; }
        #preview code { background: #f3f4f6; padding: 0.15em 0.35em; border-radius: 0.25rem; }
        #preview pre { background: #0f172a; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow: auto; }
        #preview pre code { background: transparent; padding: 0; }
    </style>
</head>
<body class="flex flex-col h-screen m-0 font-sans bg-gray-50 text-gray-800" style="font-family: 'Open Sans', sans-serif;">
    <div class="bg-gray-100 p-4 flex justify-between items-center">
        <div>
            <h3 class="text-lg font-semibold mb-2">Writer</h3>
            <div role="tablist" class="tabs tabs-lift tabs-sm" id="open-files">
                <!-- Open files will be listed here as tabs -->
            </div>
        </div>
        <div class="flex space-x-2 items-center">
            <button onclick="toggleLeft()" class="btn btn-circle">⟪⟪</button>
            <button onclick="toggleRight()" class="btn btn-circle">✦</button>
            <button onclick="popoutPreview()" class="btn btn-circle">→</button>
            <button class="btn btn-circle text-2xl" onclick="toggleAiSettings()">⚙︎</button>
        </div>
    </div>
    <div class="flex flex-1 overflow-hidden">
        <div class="w-1/5 bg-gray-100 p-4 overflow-y-auto" id="left-panel">
            <div class="flex items-center gap-2 mb-4">
                <button type="button" onclick="addFolder()" class="btn btn-sm btn-accent">load</button>
                <button type="button" onclick="newFile()" class="btn btn-sm btn-primary">new</button>
            </div>
            <h4 class="text-md font-semibold">Files</h4>
            <ul class="list-none p-0">
                <!-- Tree will be rendered here by JS -->
            </ul>
        </div>
        <div class="flex-1 p-4 relative">
            <textarea id="editor" placeholder="Select a file to edit..." class="w-full h-full border-none resize-none bg-white p-4 rounded shadow-sm"></textarea>
            <img id="image-viewer" class="w-full h-full object-contain hidden absolute inset-0" />
            <iframe id="pdf-viewer" class="w-full h-full hidden absolute inset-0"></iframe>
            <!-- Find Panel -->
            <div id="find-panel" class="absolute top-2 right-4 bg-white shadow rounded border border-gray-200 p-2 hidden">
                <div class="flex items-center gap-2 mb-1">
                    <input id="find-input" type="text" class="input input-bordered input-xs w-52" placeholder="Find..." />
                    <span id="find-count" class="text-xs text-gray-500">0/0</span>
                    <button type="button" class="btn btn-xs" onclick="findPrev()" title="Previous (Shift+Enter)">↑</button>
                    <button type="button" class="btn btn-xs" onclick="findNext()" title="Next (Enter)">↓</button>
                    <button type="button" class="btn btn-ghost btn-xs" onclick="closeFind()" title="Close (Esc)">✕</button>
                </div>
                <div class="flex items-center gap-2">
                    <input id="replace-input" type="text" class="input input-bordered input-xs w-52" placeholder="Replace with..." />
                    <button type="button" class="btn btn-xs btn-primary" onclick="replaceCurrent()" title="Replace (Enter)">Replace</button>
                    <button type="button" class="btn btn-xs btn-accent" onclick="replaceAll()" title="Replace All">Replace All</button>
                </div>
            </div>
        </div>
        <div class="w-1/3 bg-gray-50 p-0 flex flex-col" id="preview-panel">
            <!-- Keep hidden preview to avoid breaking existing code paths -->
            <div id="preview" class="hidden"></div>

            <!-- AI Agent Panel -->
            <div class="flex-1 overflow-y-auto p-3" id="ai-messages" aria-live="polite"></div>
            <div id="ai-spinner" class="loading loading-spinner loading-sm hidden mx-auto my-2"></div>
            <div class="border-t border-gray-200 p-2 space-y-2">
                <div class="flex items-center justify-between">
                    <span class="text-sm text-gray-600">Writer agent</span>
                </div>
                
                <div class="flex gap-2 items-start">
                    <textarea id="ai-input" placeholder="Ask the AI to modify the current file..." class="textarea textarea-bordered textarea-sm w-full" rows="3"></textarea>
                    <div class="flex flex-col gap-1">
                        <button id="ai-send-btn" class="btn btn-ghost btn-sm" onclick="aiSend()">►</button>
                        <button id="ai-stop-btn" class="btn btn-error btn-sm hidden" onclick="stopAiSend()">⏹</button>
                    </div>
                </div>
                
            </div>
        </div>
    </div>
    <!-- Context Menu -->
    <div id="context-menu" class="hidden">
        <div id="cm-new-file" class="item" onclick="newFileInContextDir()">New File</div>
        <div id="cm-new-folder" class="item" onclick="newFolderInContextDir()">New Folder</div>
        <div class="item" onclick="renameSelected()">Rename</div>
        <div class="item" onclick="deleteSelected()">Delete</div>
    </div>
    <div class="bg-gray-100 p-4 flex justify-between items-center">
        <span id="word-count" class="text-sm">Word count: 0</span>
        <div class="flex space-x-2">
            <button id="save-btn" onclick="saveFile()" class="btn btn-sm  btn-success hidden">Save</button>
            <button id="download-btn" onclick="downloadFile()" class="btn btn-sm btn-info hidden">download</button>
        </div>
    </div>
    <!-- Settings Modal -->
    <dialog id="settings-modal" class="modal">
        <div class="modal-box">
            <h3 class="font-bold text-lg mb-2">Settings</h3>
            <div class="space-y-3">
                <label class="form-control w-full">
                    <div class="label"><span class="label-text">Google API key</span></div>
                    <input id="ai-api-key-modal" type="password" class="input input-bordered input-sm w-full" placeholder="sk-..." />
                    
                </label>
                <div class="h-3"></div>
                <label class="form-control w-full">
                    <div class="label"><span class="label-text">Gemini model</span></div>
                    <select id="ai-model-modal" class="select select-bordered select-sm w-full">
                        <option value="gemini-2.5-flash">gemini-2.5-flash</option>
                        <option value="gemini-2.5-pro">gemini-2.5-pro</option>
                    </select>
                </label>
                <label class="cursor-pointer flex items-center gap-2 text-sm">
                    <input id="ai-auto-apply-modal" type="checkbox" class="checkbox checkbox-xs" />
                    <span>Auto-apply file changes</span>
                </label>
            </div>
            <div class="modal-action">
                <button class="btn btn-ghost" onclick="document.getElementById('settings-modal').close()">Cancel</button>
                <button class="btn btn-primary" onclick="saveAiSettings()">Save</button>
            </div>
        </div>
        <form method="dialog" class="modal-backdrop">
            <button>close</button>
        </form>
    </dialog>
    <script>
        'use strict';
        let currentFile = '';
        let opfsRoot;
        let currentBlobUrl = null; // track last created object URL to revoke
        const MAX_PREVIEW_BYTES = 500000; // ~500KB limit for preview to keep it responsive
        let previewWin = null; // external preview window reference
        let abortController = null; // for cancelling AI requests
        // Gemini API configuration
        const GEMINI_API_BASE = 'https://generativelanguage.googleapis.com/v1beta';
        // Model configuration
        const ALLOWED_MODELS = ['gemini-2.5-flash', 'gemini-2.5-pro'];
        const DEFAULT_MODEL = 'gemini-2.5-flash';
        // Track per-file state (dirty, lastSaved, and in-memory buffer)
        const fileState = {}; // { [filename]: { dirty: boolean, lastSaved: string, buffer: string } }
        // File preview type constants (avoid re-creating arrays repeatedly)
        const IMAGE_EXTS = Object.freeze(['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp']);
        const PDF_EXTS = Object.freeze(['.pdf']);

        /*
         Sections overview (logical modules):
         - OPFS: initOPFS, getFileHandle, read/write OPFS files, settings, tree build/copy helpers
         - UI: preview, tabs, editor state, toasts, context menu, keyboard shortcuts
         - AI: settings modal, aiSend (streaming + save), code block extraction
         The actual function order below remains mostly the same to minimize risk,
         but a consolidated `Modules` object is created at the end for grouped access.
        */

        // Simple debounce utility to reduce heavy work on fast events
        function debounce(fn, delay) {
            let t;
            return (...args) => {
                clearTimeout(t);
                t = setTimeout(() => fn(...args), delay);
            };
        }

        async function initOPFS() {
            if ('storage' in navigator && 'getDirectory' in navigator.storage) {
                opfsRoot = await navigator.storage.getDirectory();
                await buildTreeFromOPFS();
                // Load persisted settings into UI controls
                await loadSettingsIntoUI();
            } else {
                alert('OPFS not supported');
            }
        }

        async function getFileHandle(path, createDirs = false, createFile = false) {
            const parts = path.split('/').filter(Boolean);
            let dir = opfsRoot;
            for (let i = 0; i < parts.length - 1; i++) {
                const segment = parts[i];
                dir = await dir.getDirectoryHandle(segment, createDirs ? { create: true } : {});
            }
            const fileName = parts[parts.length - 1];
            return await dir.getFileHandle(fileName, createFile ? { create: true } : {});
        }

        initOPFS();

        async function loadFile(filename) {
            try {
                // Snapshot the current editor buffer before switching files
                if (currentFile) {
                    const prev = fileState[currentFile] || (fileState[currentFile] = { dirty: false, lastSaved: '', buffer: '' });
                    // Only snapshot for text editor-visible files
                    if (!document.getElementById('editor').classList.contains('hidden')) {
                        prev.buffer = document.getElementById('editor').value;
                    }
                }
                const fileHandle = await getFileHandle(filename);
                const file = await fileHandle.getFile();
                const ext = filename.substring(filename.lastIndexOf('.')).toLowerCase();
                currentFile = filename;
                if (IMAGE_EXTS.includes(ext)) {
                    if (currentBlobUrl) { URL.revokeObjectURL(currentBlobUrl); currentBlobUrl = null; }
                    document.getElementById('editor').classList.add('hidden');
                    document.getElementById('pdf-viewer').classList.add('hidden');
                    document.getElementById('save-btn').classList.add('hidden');
                    const img = document.getElementById('image-viewer');
                    currentBlobUrl = URL.createObjectURL(file);
                    img.src = currentBlobUrl;
                    img.classList.remove('hidden');
                    document.getElementById('download-btn').classList.remove('hidden');
                } else if (PDF_EXTS.includes(ext)) {
                    if (currentBlobUrl) { URL.revokeObjectURL(currentBlobUrl); currentBlobUrl = null; }
                    document.getElementById('editor').classList.add('hidden');
                    document.getElementById('image-viewer').classList.add('hidden');
                    document.getElementById('save-btn').classList.add('hidden');
                    const iframe = document.getElementById('pdf-viewer');
                    currentBlobUrl = URL.createObjectURL(file);
                    iframe.src = currentBlobUrl;
                    iframe.classList.remove('hidden');
                    document.getElementById('download-btn').classList.remove('hidden');
                } else {
                    if (currentBlobUrl) { URL.revokeObjectURL(currentBlobUrl); currentBlobUrl = null; }
                    document.getElementById('image-viewer').classList.add('hidden');
                    document.getElementById('pdf-viewer').classList.add('hidden');
                    // Use in-memory buffer if we have unsaved edits; otherwise read from OPFS
                    const st = fileState[filename];
                    let content;
                    if (st && st.dirty && typeof st.buffer === 'string') {
                        content = st.buffer;
                    } else {
                        content = await file.text();
                    }
                    document.getElementById('editor').value = content;
                    document.getElementById('editor').classList.remove('hidden');
                    document.getElementById('save-btn').classList.remove('hidden');
                    document.getElementById('download-btn').classList.remove('hidden');
                    // initialize or refresh file state
                    const existing = fileState[filename] || {};
                    fileState[filename] = {
                        dirty: !!existing.dirty && content === (existing.buffer ?? content) ? true : (existing.dirty || false),
                        lastSaved: existing.lastSaved ?? content,
                        buffer: content
                    };
                }
                debouncedUpdate();
                addToOpenFiles(filename);
                highlightActiveTab(filename);
                highlightActiveFileInTree(filename);
            } catch (err) {
                console.error('Error loading file:', err);
            }
        }

        function updateWordCount() {
            if (!document.getElementById('editor').classList.contains('hidden')) {
                const text = document.getElementById('editor').value;
                const words = text.trim().split(/\s+/).filter(word => word.length > 0);
                document.getElementById('word-count').textContent = 'Word count: ' + words.length;
            } else {
                document.getElementById('word-count').textContent = 'Word count: N/A';
            }
        }

        function updatePreview() {
            if (!document.getElementById('editor').classList.contains('hidden') && currentFile) {
                const content = document.getElementById('editor').value;
                if (currentFile.endsWith('.md')) {
                    let toRender = content;
                    if (toRender.length > MAX_PREVIEW_BYTES) {
                        toRender = toRender.slice(0, MAX_PREVIEW_BYTES);
                        const html = `<div class=\"text-sm text-gray-500\">Preview truncated for performance.</div>` + marked.parse(toRender);
                        document.getElementById('preview').innerHTML = html;
                        renderPreviewToWindow(html);
                    } else {
                        const html = marked.parse(toRender);
                        document.getElementById('preview').innerHTML = html;
                        renderPreviewToWindow(html);
                    }
                } else {
                    let toRender = content;
                    let truncatedNotice = '';
                    if (toRender.length > MAX_PREVIEW_BYTES) {
                        toRender = toRender.slice(0, MAX_PREVIEW_BYTES);
                        truncatedNotice = '<div class="text-sm text-gray-500">Preview truncated for performance.</div>';
                    }
                    const html = truncatedNotice + '<pre>' + toRender.replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</pre>';
                    document.getElementById('preview').innerHTML = html;
                    renderPreviewToWindow(html);
                }
            } else {
                const prev = document.getElementById('preview');
                if (prev) prev.innerHTML = '';
                renderPreviewToWindow('');
            }
        }

        function popoutPreview() {
            try {
                if (previewWin && !previewWin.closed) {
                    previewWin.focus();
                    return;
                }
                previewWin = window.open('', 'writerPreview', 'width=900,height=800');
                if (!previewWin) return;
                const doc = previewWin.document;
                doc.open();
                doc.write(`<!DOCTYPE html>
<html>
<head>
<meta charset=\"utf-8\" />
<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />
<title>Preview</title>
<link href=\"https://fonts.googleapis.com/css2?family=EB+Garamond:wght@400;700&display=swap\" rel=\"stylesheet\" />
<style>
  body { font-family: Garamond, 'EB Garamond', Georgia, serif; font-size: 24px; margin: 0; padding: 1.25rem; background: #f8fafc; color: #0f172a; }
  .container { max-width: 900px; margin: 0 auto; }
  /* Mirror preview styles */
  .container { line-height: 1.7; }
  .container h1 { font-size: 2rem; font-weight: 700; margin: 1.25em 0 0.6em; }
  .container h2 { font-size: 1.75rem; font-weight: 700; margin: 1.2em 0 0.55em; }
  .container h3 { font-size: 1.5rem; font-weight: 600; margin: 1.1em 0 0.5em; }
  .container h4 { font-size: 1.25rem; font-weight: 600; margin: 1em 0 0.5em; }
  .container h5 { font-size: 1.125rem; font-weight: 600; margin: 0.9em 0 0.5em; }
  .container h6 { font-size: 1rem; font-weight: 600; margin: 0.8em 0 0.5em; text-transform: uppercase; letter-spacing: .02em; }
  .container p, .container ul, .container ol { margin: 0.75em 0; }
  .container ul { list-style: disc; padding-left: 1.5rem; }
  .container ol { list-style: decimal; padding-left: 1.5rem; }
  .container code { background: #f3f4f6; padding: 0.15em 0.35em; border-radius: 0.25rem; }
  .container pre { background: #0f172a; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow: auto; }
  .container pre code { background: transparent; padding: 0; }
</style>
</head>
<body><div class=\"container\" id=\"ext-preview\"></div></body>
</html>`);
                doc.close();
                // Push current preview content immediately
                renderPreviewToWindow(document.getElementById('preview').innerHTML);
                // When external window closes, clear reference
                previewWin.addEventListener('beforeunload', () => { previewWin = null; });
            } catch (e) {
                console.error('Failed to open preview window', e);
            }
        }

        function renderPreviewToWindow(html) {
            if (!previewWin || previewWin.closed) return;
            try {
                const target = previewWin.document.getElementById('ext-preview');
                if (target) target.innerHTML = html || '';
            } catch (e) {
                // Ignore cross-origin errors
            }
        }

        // ===== AI Panel Helpers =====
        async function toggleAiSettings() {
            // Open DaisyUI modal and sync values
            const modal = document.getElementById('settings-modal');
            if (!modal) return;
            // Prefill from settings.json
            const s = await readSettings();
            const modalModel = document.getElementById('ai-model-modal');
            const modalAuto = document.getElementById('ai-auto-apply-modal');
            const modalStream = document.getElementById('ai-stream-modal');
            if (modalModel && s.model) modalModel.value = s.model;
            if (modalAuto && typeof s.autoApply === 'boolean') modalAuto.checked = s.autoApply;
            // Load API key from OPFS
            const modalKey = document.getElementById('ai-api-key-modal');
            if (modalKey) {
                try {
                    modalKey.value = s.apiKey || '';
                    if (modalStream && typeof s.stream === 'boolean') modalStream.checked = s.stream;
                } catch {}
            }
            if (modal.showModal) modal.showModal();
        }

        async function saveAiSettings() {
            const modal = document.getElementById('settings-modal');
            const modalModel = document.getElementById('ai-model-modal');
            const modalAuto = document.getElementById('ai-auto-apply-modal');
            const modalKey = document.getElementById('ai-api-key-modal');
            const modalStream = document.getElementById('ai-stream-modal');
            const modelSel = document.getElementById('ai-model');
            const autoChk = document.getElementById('ai-auto-apply');
            if (modelSel && modalModel) modelSel.value = modalModel.value;
            if (autoChk && modalAuto) autoChk.checked = modalAuto.checked;
            try {
                const s = await readSettings();
                const updated = {
                    ...s,
                    apiKey: (modalKey?.value || '').trim(),
                    model: modalModel ? modalModel.value : (s.model || ''),
                    autoApply: modalAuto ? !!modalAuto.checked : (typeof s.autoApply === 'boolean' ? s.autoApply : true),
                    stream: modalStream ? !!modalStream.checked : (typeof s.stream === 'boolean' ? s.stream : true)
                };
                await writeSettings(updated);
            } catch {}
            if (modal && modal.close) modal.close();
        }

        async function readOpfsFileText(filename) {
            try {
                // Use path-aware helper so nested files work reliably
                const fh = await getFileHandle(filename, false, false);
                const f = await fh.getFile();
                return (await f.text()).trim();
            } catch { return ''; }
        }

        async function writeOpfsFileText(filename, text) {
            // Ensure directories exist and create file if missing
            const fh = await getFileHandle(filename, true, true);
            const w = await fh.createWritable();
            await w.write(text);
            await w.close();
        }

        // ===== settings.json helpers =====
        async function readSettings() {
            try {
                const txt = await readOpfsFileText('settings.json');
                if (!txt) return {};
                return JSON.parse(txt);
            } catch { return {}; }
        }

        async function writeSettings(settings) {
            const json = JSON.stringify(settings || {}, null, 2);
            await writeOpfsFileText('settings.json', json);
        }

        async function getApiKey() {
            const s = await readSettings();
            return s.apiKey || '';
        }

        async function loadSettingsIntoUI() {
            // UI is driven by Settings modal only; nothing to preload here.
            await readSettings(); // retain for side-effects if needed later
        }

        // promptForApiKey is deprecated; use Settings modal instead

        function toast(msg) {
            const box = document.createElement('div');
            box.className = 'fixed bottom-3 right-3 bg-black/80 text-white text-sm px-3 py-2 rounded';
            box.textContent = msg;
            document.body.appendChild(box);
            setTimeout(() => box.remove(), 1800);
        }

        function downloadContentAs(filename, content, mime = 'text/plain') {
            try {
                const blob = new Blob([content], { type: mime });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = (filename || 'untitled.txt').split('/').pop();
                a.click();
                URL.revokeObjectURL(url);
            } catch (e) {
                console.error('Download fallback failed:', e);
            }
        }

        function addAiMessage(html, role = 'assistant') {
            const wrap = document.createElement('div');
            wrap.className = role === 'user' ? 'bg-base-200 rounded p-2 mb-2' : 'bg-base-100 rounded p-2 mb-2';
            wrap.innerHTML = html;
            const container = document.getElementById('ai-messages');
            container.appendChild(wrap);
            container.scrollTop = container.scrollHeight;
        }

        function extractCodeBlock(text) {
            // Extract ALL triple-backtick blocks and return the longest one.
            // This avoids saving partial or empty code blocks when the model emits multiple blocks.
            if (!text) return null;
            const regex = /```[\s\S]*?```/g;
            const blocks = [];
            let m;
            while ((m = regex.exec(text)) !== null) {
                blocks.push(m[0]);
            }
            if (blocks.length === 0) return null;
            // Choose the longest block, which is most likely the full file content
            let longest = blocks.reduce((a, b) => (a.length >= b.length ? a : b));
            // Strip the fences and optional language tag
            longest = longest.replace(/^```[a-zA-Z0-9_\-]*\n?/, '').replace(/```\s*$/, '');
            return longest;
        }

        async function aiSend() {
            if (!currentFile) {
                // Allow user to create a file so the response can be saved
                const fname = prompt('No file is open. Enter a new file name to create (e.g., notes/untitled.md):', 'untitled.md');
                if (!fname) { toast('Open or create a file first'); return; }
                try {
                    const fh = await getFileHandle(fname, true, true);
                    const w = await fh.createWritable();
                    await w.write('');
                    await w.close();
                    currentFile = fname;
                    addToOpenFiles(currentFile);
                    highlightActiveTab(currentFile);
                    const expandedBefore = getExpandedPaths();
                    await buildTreeFromOPFS();
                    restoreExpandedPaths(expandedBefore);
                    document.getElementById('editor').classList.remove('hidden');
                    document.getElementById('save-btn').classList.remove('hidden');
                    document.getElementById('download-btn').classList.remove('hidden');
                } catch (e) {
                    console.error('Failed to create file for AI response', e);
                    toast('Failed to create file');
                    return;
                }
            }
            let apiKey = await getApiKey();
            if (!apiKey) {
                toast('Set your API key in Settings (⚙︎)');
                await toggleAiSettings();
                return;
            }
            const prompt = document.getElementById('ai-input').value.trim();
            if (!prompt) return;
            const content = document.getElementById('editor').value;
            let model = DEFAULT_MODEL;
            let streamEnabled = true;
            let autoApply = true;
            try {
                const s = await readSettings();
                const candidate = s.model || model;
                model = ALLOWED_MODELS.includes(candidate) ? candidate : model;
                if (typeof s.stream === 'boolean') streamEnabled = s.stream;
                if (typeof s.autoApply === 'boolean') autoApply = s.autoApply;
            } catch {}

            addAiMessage(`<div class='text-xs text-gray-500'>You → ${currentFile}</div><div>${prompt.replace(/</g,'&lt;')}</div>`, 'user');
            document.getElementById('ai-input').value = '';

            const systemBase = `You are a meticulous text editing and writing assistant with access to all files in the workspace.
You will be given the current file path and its entire content, along with a list of all other files and their contents.
CRITICAL OUTPUT REQUIREMENTS:
1) Always respond with a SINGLE fenced Markdown code block (triple backticks).
2) That block MUST contain ONLY the FULL updated file content, with no commentary before or after.
3) If no change is needed or you are unsure, return the ORIGINAL content in the code block.
4) Never output an empty code block.`;
            const userMsgBase = async (filePath, fileContent, task) => {
                let msg = `File: ${filePath}\n\n--- BEGIN CURRENT FILE CONTENT ---\n${fileContent}\n--- END CURRENT FILE CONTENT ---\n\nTask: ${task}\n\n`;
                // List all files in the workspace
                const tree = await buildTree(opfsRoot);
                const allFiles = [];
                const collectFiles = (items, path = '') => {
                    for (const item of items) {
                        const fullPath = path ? `${path}/${item.name}` : item.name;
                        if (item.isDir) {
                            collectFiles(item.children, fullPath);
                        } else {
                            allFiles.push(fullPath);
                        }
                    }
                };
                collectFiles(tree);
                msg += `Available files in workspace: ${allFiles.join(', ')}\n\n`;
                // Include content of specific files mentioned in the task
                const fileRegex = /\b([a-zA-Z0-9_\-\/\.]+(?:\.[a-zA-Z0-9]+)?)\b/g;
                const mentionedFiles = new Set();
                let match;
                while ((match = fileRegex.exec(task)) !== null) {
                    const potentialFile = match[1];
                    if (allFiles.includes(potentialFile) && potentialFile !== filePath) {
                        mentionedFiles.add(potentialFile);
                    }
                }
                for (const fp of mentionedFiles) {
                    try {
                        const content = await readOpfsFileText(fp);
                        msg += `--- BEGIN FILE: ${fp} ---\n${content}\n--- END FILE: ${fp} ---\n\n`;
                    } catch (e) {
                        console.warn('Could not read mentioned file for AI:', fp, e);
                    }
                }
                msg += 'Return only the updated current file content in a single fenced code block.';
                return msg;
            };

            // Create a streaming assistant message container
            const container = document.getElementById('ai-messages');
            const wrap = document.createElement('div');
            wrap.className = 'bg-base-100 rounded p-2 mb-2';
            wrap.innerHTML = `<div class='text-xs text-gray-500'>Writer → ${currentFile}</div><pre class='whitespace-pre-wrap' id='ai-stream-msg'></pre>`;
            container.appendChild(wrap);
            container.scrollTop = container.scrollHeight;
            const streamPre = wrap.querySelector('#ai-stream-msg');

            let fullText = '';
            // Cache DOM elements to avoid repeated lookups
            const spinner = document.getElementById('ai-spinner');
            const sendBtn = document.getElementById('ai-send-btn');
            const stopBtn = document.getElementById('ai-stop-btn');
            const input = document.getElementById('ai-input');
            spinner.classList.remove('hidden');
            sendBtn.disabled = true;
            stopBtn.classList.remove('hidden');
            input.disabled = true;
            // Create abort controller for cancellation
            abortController = new AbortController();
            try {
                const endpoint = `${GEMINI_API_BASE}/models/${encodeURIComponent(model)}:${streamEnabled ? 'streamGenerateContent' : 'generateContent'}?key=${encodeURIComponent(apiKey)}${streamEnabled ? '&alt=sse' : ''}`;
                const body = {
                    systemInstruction: { role: 'system', parts: [{ text: systemBase }] },
                    contents: [
                        { role: 'user', parts: [{ text: await userMsgBase(currentFile, content, prompt) }] }
                    ],
                    generationConfig: { temperature: 0.3 }
                };
                const res = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body),
                    signal: abortController.signal
                });
                if (!res.ok) {
                    let bodyText = '';
                    try { bodyText = await res.text(); } catch {}
                    throw new Error(`LLM error ${res.status}${bodyText ? ': ' + bodyText : ''}`);
                }
                if (!streamEnabled) {
                    // Non-streaming: parse JSON fully (Gemini generateContent)
                    const data = await res.json();
                    const candidates = Array.isArray(data.candidates) ? data.candidates : [];
                    if (candidates.length) {
                        const parts = (candidates[0].content && Array.isArray(candidates[0].content.parts)) ? candidates[0].content.parts : [];
                        for (const p of parts) { if (typeof p.text === 'string') fullText += p.text; }
                    }
                } else {
                    if (!res.body) throw new Error('No response body for stream');
                    const reader = res.body.getReader();
                    const decoder = new TextDecoder('utf-8');
                    let done = false;
                    let buffer = '';
                    while (!done) {
                        const { value, done: d } = await reader.read();
                        done = d;
                        if (value) buffer += decoder.decode(value, { stream: true });
                        // Process complete SSE frames separated by blank line
                        let frameSplit;
                        while ((frameSplit = buffer.indexOf('\n\n')) >= 0) {
                            const frame = buffer.slice(0, frameSplit);
                            buffer = buffer.slice(frameSplit + 2);
                            const lines = frame.split('\n');
                            for (const raw of lines) {
                                const line = raw.trim();
                                if (!line || !line.startsWith('data:')) continue;
                                const payload = line.slice(5).trim();
                                if (payload === '[DONE]') { done = true; break; }
                                try {
                                    const json = JSON.parse(payload);
                                    // Each SSE message is a partial GenerateContentResponse
                                    const cands = Array.isArray(json.candidates) ? json.candidates : [];
                                    if (cands.length) {
                                        const parts = (cands[0].content && Array.isArray(cands[0].content.parts)) ? cands[0].content.parts : [];
                                        let delta = '';
                                        for (const p of parts) { if (typeof p.text === 'string') delta += p.text; }
                                        if (delta) {
                                            fullText += delta;
                                            streamPre.textContent = fullText;
                                            container.scrollTop = container.scrollHeight;
                                        }
                                    }
                                } catch {}
                            }
                        }
                    }
                }
                // Finished streaming; extract updated file content
                let block = extractCodeBlock(fullText);
                if (block == null) {
                    block = fullText || '';
                }
                // If empty, auto-retry once with stricter non-streaming request
                if (!block || block.trim().length === 0) {
                    try {
                        const strictSystem = systemBase + `\n\nSTRICT MODE: You MUST output a single fenced code block containing the FULL file content. If you cannot produce changes, output the ORIGINAL content. Do not include any explanations.`;
                        const retryEndpoint = `${GEMINI_API_BASE}/models/${encodeURIComponent(model)}:generateContent?key=${encodeURIComponent(apiKey)}`;
                        const retryBody = {
                            systemInstruction: { role: 'system', parts: [{ text: strictSystem }] },
                            contents: [
                                { role: 'user', parts: [{ text: await userMsgBase(currentFile, content, prompt) }] }
                            ],
                            generationConfig: { temperature: 0.2 }
                        };
                        const retryRes = await fetch(retryEndpoint, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(retryBody)
                        });
                        if (retryRes.ok) {
                            const data2 = await retryRes.json();
                            let retryText = '';
                            const candidates2 = Array.isArray(data2.candidates) ? data2.candidates : [];
                            if (candidates2.length) {
                                const parts2 = (candidates2[0].content && Array.isArray(candidates2[0].content.parts)) ? candidates2[0].content.parts : [];
                                for (const p of parts2) { if (typeof p.text === 'string') retryText += p.text; }
                            }
                            let retryBlock = extractCodeBlock(retryText) || retryText || '';
                            if (retryBlock && retryBlock.trim().length > 0) {
                                block = retryBlock;
                            }
                        }
                    } catch (e2) {
                        console.warn('Retry failed', e2);
                    }
                }
                // Guard: never overwrite the file with an empty response
                if (!block || block.trim().length === 0) {
                    if (autoApply) {
                        addAiMessage(`<div class='text-warning text-sm'>AI returned empty content twice. Saving ORIGINAL content to keep your file intact.</div>`, 'assistant');
                        block = content; // fall back to original file content
                    } else {
                        addAiMessage(`<div class='text-warning text-sm'>AI returned empty content. No changes applied to file.</div>`, 'assistant');
                        return;
                    }
                }
                // Apply changes only if autoApply is enabled
                if (autoApply) {
                    // Write the response to the currently open file
                    document.getElementById('editor').value = block;
                    debouncedUpdate();
                    await saveFile();
                    addAiMessage(`<div class='text-xs text-gray-500'>Saved to ${currentFile}</div>`, 'assistant');
                } else {
                    // Show response in panel without applying to file
                    addAiMessage(`<div class='text-xs text-gray-500'>Response received. Enable auto-apply in settings to apply changes automatically.</div><pre class='whitespace-pre-wrap bg-gray-100 p-2 rounded text-sm'>${block.replace(/</g, '&lt;')}</pre>`, 'assistant');
                }
            } catch (e) {
                if (e.name === 'AbortError') {
                    addAiMessage(`<div class='text-warning text-sm'>AI request cancelled.</div>`, 'assistant');
                } else {
                    console.error(e);
                    addAiMessage(`<div class='text-error text-sm'>${String(e)}</div>`, 'assistant');
                }
            } finally {
                spinner.classList.add('hidden');
                sendBtn.disabled = false;
                stopBtn.classList.add('hidden');
                input.disabled = false;
                abortController = null;
            }
        }

        function stopAiSend() {
            if (abortController) {
                abortController.abort();
                addAiMessage(`<div class='text-warning text-sm'>AI request stopped by user.</div>`, 'assistant');
            }
        }

        // Trigger AI send with Cmd+Enter (Mac) or Ctrl+Enter (others)
        (function(){
            const aiInput = document.getElementById('ai-input');
            if (!aiInput) return;
            aiInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                    e.preventDefault();
                    e.stopPropagation();
                    const btn = document.getElementById('ai-send-btn');
                    if (btn && !btn.disabled) {
                        aiSend();
                    }
                }
            });
        })();

        

        function addToOpenFiles(filename) {
            const container = document.getElementById('open-files');
            const existing = Array.from(container.children).find(el => el.dataset && el.dataset.filename === filename);
            if (!existing) {
                const tab = document.createElement('a');
                tab.role = 'tab';
                tab.className = 'tab tab-sm flex items-center max-w-xs';
                tab.dataset.filename = filename;
                tab.title = filename;
                if (filename === currentFile) {
                    tab.classList.add('tab-active');
                }
                tab.onclick = () => loadFile(filename);
                tab.innerHTML = `<span class="truncate flex-1 min-w-0" title="${filename}">${filename}</span>
                    <span class="dirty-dot ml-2 text-amber-700 hidden">●</span>
                    <button class="btn btn-ghost btn-xs ml-2 shrink-0" onclick="closeTab(event, '${filename}')">✕</button>`;
                container.appendChild(tab);
                // sync initial visual state
                updateTabVisual(filename);
            }
        }

        function highlightActiveTab(filename) {
            const tabs = document.querySelectorAll('#open-files .tab');
            tabs.forEach(tab => {
                const fname = tab.dataset && tab.dataset.filename ? tab.dataset.filename : tab.textContent.trim();
                if (fname === filename) {
                    tab.classList.add('tab-active');
                } else {
                    tab.classList.remove('tab-active');
                }
                // keep dirty style if needed
                updateTabVisual(fname);
            });
        }

        function highlightActiveFileInTree(filename) {
            // Remove active class from all file spans
            const allSpans = document.querySelectorAll('#left-panel [data-path]');
            allSpans.forEach(span => span.classList.remove('active-file'));
            // Add to the selected file if it exists
            if (filename) {
                const activeSpan = findSpanByPath(filename);
                if (activeSpan) activeSpan.classList.add('active-file');
            }
        }

        function setDirty(filename, isDirty) {
            if (!filename) return;
            fileState[filename] = fileState[filename] || { dirty: false, lastSaved: '' };
            fileState[filename].dirty = !!isDirty;
            updateTabVisual(filename);
        }

        function updateTabVisual(filename) {
            const container = document.getElementById('open-files');
            const tab = Array.from(container.children).find(el => el.dataset && el.dataset.filename === filename);
            if (!tab) return;
            const st = fileState[filename] || { dirty: false };
            const dot = tab.querySelector('.dirty-dot');
            const star = tab.querySelector('.star-marker');
            if (st.dirty) {
                tab.classList.add('tab-dirty');
                if (dot) dot.classList.remove('hidden');
                if (star) star.classList.remove('hidden');
            } else {
                tab.classList.remove('tab-dirty');
                if (dot) dot.classList.add('hidden');
                if (star) star.classList.add('hidden');
            }
        }

        function closeTab(event, filename) {
            event.stopPropagation();
            const container = document.getElementById('open-files');
            const tab = Array.from(container.children).find(el => el.dataset && el.dataset.filename === filename);
            if (tab) {
                const isActive = tab.classList.contains('tab-active');
                container.removeChild(tab);
                // remove state tracking
                delete fileState[filename];
                if (isActive) {
                    // Switch to another open tab if available
                    const remaining = container.querySelectorAll('.tab');
                    if (remaining.length > 0) {
                        const next = remaining[remaining.length - 1];
                        const nextFile = next.dataset && next.dataset.filename ? next.dataset.filename : next.textContent.trim();
                        loadFile(nextFile);
                    } else {
                        // No tabs left: clear editor and preview
                        currentFile = '';
                        document.getElementById('editor').value = '';
                        document.getElementById('editor').classList.add('hidden');
                        document.getElementById('image-viewer').classList.add('hidden');
                        document.getElementById('pdf-viewer').classList.add('hidden');
                        document.getElementById('save-btn').classList.add('hidden');
                        document.getElementById('download-btn').classList.add('hidden');
                        document.getElementById('preview').innerHTML = '';
                        document.getElementById('word-count').textContent = 'Word count: N/A';
                        highlightActiveTab('');
                        highlightActiveFileInTree('');
                    }
                }
            }
        }

        const debouncedUpdate = debounce(() => { updateWordCount(); updatePreview(); }, 150);
        function onEditorInput() {
            if (currentFile) {
                setDirty(currentFile, true);
                // Update in-memory buffer for current file
                const st = fileState[currentFile] || (fileState[currentFile] = { dirty: true, lastSaved: '', buffer: '' });
                st.buffer = document.getElementById('editor').value;
            }
            // If find panel is open, recompute matches on content change
            const fp = document.getElementById('find-panel');
            if (fp && !fp.classList.contains('hidden')) {
                const q = (document.getElementById('find-input')?.value || '').trim();
                if (q) computeFindMatches(q);
            }
            debouncedUpdate();
        }
        document.getElementById('editor').addEventListener('input', onEditorInput);

        // ===== Find feature (simple literal match, case-sensitive) =====
        let findState = { query: '', matches: [], current: -1 };

        function isEditorVisible() {
            const ed = document.getElementById('editor');
            return ed && !ed.classList.contains('hidden');
        }

        function openFind() {
            if (!isEditorVisible()) { toast('Find works only for text files.'); return; }
            const panel = document.getElementById('find-panel');
            const input = document.getElementById('find-input');
            panel.classList.remove('hidden');
            // Pre-fill with current selection if any
            const ed = document.getElementById('editor');
            const sel = ed.value.substring(ed.selectionStart, ed.selectionEnd);
            if (sel && sel.indexOf('\n') === -1) {
                input.value = sel;
            }
            input.focus();
            input.select();
            const q = (input.value || '').trim();
            if (q) {
                computeFindMatches(q);
                // If no current selection within matches, jump to first
                if (findState.matches.length) {
                    findState.current = 0;
                    goToMatchAtIndex(findState.current);
                } else {
                    updateFindCount();
                }
            } else {
                findState = { query: '', matches: [], current: -1 };
                updateFindCount();
            }
        }

        function closeFind() {
            const panel = document.getElementById('find-panel');
            if (panel) panel.classList.add('hidden');
        }

        function computeFindMatches(query) {
            if (!isEditorVisible()) { findState = { query: '', matches: [], current: -1 }; updateFindCount(); return; }
            const text = document.getElementById('editor').value;
            const q = String(query || '');
            const matches = [];
            if (q.length > 0) {
                let idx = 0;
                while (true) {
                    const pos = text.indexOf(q, idx);
                    if (pos === -1) break;
                    matches.push(pos);
                    idx = pos + (q.length || 1);
                }
            }
            // Try to keep current near same character if possible
            let cur = -1;
            if (matches.length > 0) {
                const ed = document.getElementById('editor');
                const caret = ed.selectionStart;
                // Choose the first match whose start >= caret; else wrap to 0
                cur = matches.findIndex(m => m >= caret);
                if (cur === -1) cur = 0;
            }
            findState = { query: q, matches, current: cur };
            updateFindCount();
        }

        function updateFindCount() {
            const el = document.getElementById('find-count');
            if (!el) return;
            const total = findState.matches.length;
            const cur = total > 0 && findState.current >= 0 ? (findState.current + 1) : 0;
            el.textContent = `${cur}/${total}`;
        }

        function goToMatchAtIndex(i) {
            if (!isEditorVisible()) return;
            const ed = document.getElementById('editor');
            const q = findState.query;
            const start = findState.matches[i];
            if (typeof start !== 'number') { updateFindCount(); return; }
            const end = start + q.length;
            ed.focus();
            if (typeof ed.setSelectionRange === 'function') {
                ed.setSelectionRange(start, end);
            } else {
                ed.selectionStart = start; ed.selectionEnd = end;
            }
            // Attempt to bring selection into view
            ed.scrollTop = ed.scrollHeight; // push to bottom
            const before = ed.value.slice(0, start);
            const lines = before.split('\n');
            // heuristic scroll by line count
            ed.scrollTop = Math.max(0, (lines.length - 5) * 18);
            updateFindCount();
        }

        function findNext() {
            if (!findState.query) {
                const q = (document.getElementById('find-input')?.value || '').trim();
                if (!q) return;
                computeFindMatches(q);
            }
            const total = findState.matches.length;
            if (!total) { updateFindCount(); return; }
            findState.current = (findState.current + 1 + total) % total;
            goToMatchAtIndex(findState.current);
        }

        function findPrev() {
            if (!findState.query) {
                const q = (document.getElementById('find-input')?.value || '').trim();
                if (!q) return;
                computeFindMatches(q);
            }
            const total = findState.matches.length;
            if (!total) { updateFindCount(); return; }
            findState.current = (findState.current - 1 + total) % total;
            goToMatchAtIndex(findState.current);
        }

        // Bind Cmd/Ctrl+F to open find. If the panel is already open, toggle focus between inputs (find <-> replace)
        function handleFindShortcut(e) {
            const isFind = (e.metaKey || e.ctrlKey) && e.key && e.key.toLowerCase() === 'f';
            if (!isFind) return;
            e.preventDefault();
            e.stopPropagation();
            const panel = document.getElementById('find-panel');
            if (panel && !panel.classList.contains('hidden')) {
                const fin = document.getElementById('find-input');
                const rin = document.getElementById('replace-input');
                // Toggle focus between find and replace inputs
                if (document.activeElement === fin && rin) { rin.focus(); rin.select(); }
                else if (fin) { fin.focus(); fin.select(); }
                else if (rin) { rin.focus(); rin.select(); }
                return;
            }
            openFind();
        }
        window.addEventListener('keydown', handleFindShortcut, { capture: true });
        document.addEventListener('keydown', handleFindShortcut, { capture: true });
        document.body.addEventListener('keydown', handleFindShortcut, { capture: true });

        // ===== Replace feature =====
        function openReplace() {
            // Ensure find panel is open
            openFind();
            const r = document.getElementById('replace-input');
            if (r) { r.focus(); r.select(); }
        }

        function replaceCurrent() {
            if (!isEditorVisible()) { toast('Replace works only for text files.'); return; }
            const q = (document.getElementById('find-input')?.value || '').trim();
            const r = document.getElementById('replace-input')?.value ?? '';
            if (!q) { return; }
            // Ensure matches are computed
            if (findState.query !== q || !findState.matches.length) {
                computeFindMatches(q);
            }
            const ed = document.getElementById('editor');
            const total = findState.matches.length;
            if (!total) { updateFindCount(); return; }
            if (findState.current < 0) findState.current = 0;
            const start = findState.matches[findState.current];
            const end = start + q.length;
            // Apply replacement
            const before = ed.value.slice(0, start);
            const after = ed.value.slice(end);
            ed.value = before + r + after;
            // Update state and caret to end of replacement
            const newCaret = before.length + r.length;
            if (typeof ed.setSelectionRange === 'function') ed.setSelectionRange(newCaret, newCaret);
            // Propagate change to buffers/state and recompute matches relative to new caret
            onEditorInput();
            computeFindMatches(q);
            // After recompute, current is set to first match >= caret. Move selection to it if exists
            const total2 = findState.matches.length;
            if (total2) {
                goToMatchAtIndex(findState.current);
            } else {
                updateFindCount();
            }
        }

        function replaceAll() {
            if (!isEditorVisible()) { toast('Replace works only for text files.'); return; }
            const q = (document.getElementById('find-input')?.value || '').trim();
            const r = document.getElementById('replace-input')?.value ?? '';
            if (!q) { return; }
            const ed = document.getElementById('editor');
            const text = ed.value;
            // Count occurrences via matches
            computeFindMatches(q);
            const count = findState.matches.length;
            if (!count) { updateFindCount(); return; }
            ed.value = text.split(q).join(r);
            onEditorInput();
            computeFindMatches(q); // now likely 0 or updated if r contains q
            updateFindCount();
            toast(`Replaced ${count} occurrence${count === 1 ? '' : 's'}`);
        }

        // Note: No separate shortcut for replace. Use Cmd/Ctrl+F to open the panel
        // and press Cmd/Ctrl+F again to toggle focus between Find and Replace inputs.

        // Wire find input behaviors
        (function(){
            const input = document.getElementById('find-input');
            if (!input) return;
            input.addEventListener('input', () => {
                const q = (input.value || '').trim();
                if (q) computeFindMatches(q); else { findState = { query: '', matches: [], current: -1 }; updateFindCount(); }
            });
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault(); e.stopPropagation();
                    if (e.shiftKey) findPrev(); else findNext();
                } else if (e.key === 'Escape') {
                    e.preventDefault(); e.stopPropagation();
                    closeFind();
                }
            });
        })();

        // Wire replace input behaviors
        (function(){
            const r = document.getElementById('replace-input');
            if (!r) return;
            r.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault(); e.stopPropagation();
                    replaceCurrent();
                } else if (e.key === 'Escape') {
                    e.preventDefault(); e.stopPropagation();
                    closeFind();
                }
            });
        })();

        function toggleDir(el) {
            const ul = el.nextElementSibling;
            if (ul && ul.tagName === 'UL') {
                ul.classList.toggle('hidden');
                const icon = el.querySelector('.toggle-icon');
                if (icon) {
                    icon.textContent = ul.classList.contains('hidden') ? '📁' : '📂';
                }
            }
        }

        function toggleLeft() {
            document.getElementById('left-panel').classList.toggle('hidden');
        }

        function toggleRight() {
            document.getElementById('preview-panel').classList.toggle('hidden');
        }

        async function newFile() {
            const filename = prompt('Enter the name of the new file (e.g., notes/newfile.txt):');
            if (!filename) return;
            try {
                const fileHandle = await getFileHandle(filename, true, true);
                const writable = await fileHandle.createWritable();
                await writable.write('');
                await writable.close();
                await buildTreeFromOPFS();
                await loadFile(filename);
            } catch (err) {
                console.error('Error creating new file:', err);
                alert('Failed to create new file');
            }
        }

        async function copyDirectoryToOPFS(dirHandle, opfsDir) {
            for await (const [name, handle] of dirHandle.entries()) {
                if (handle.kind === 'file') {
                    const file = await handle.getFile();
                    const opfsFile = await opfsDir.getFileHandle(name, { create: true });
                    const writable = await opfsFile.createWritable();
                    await writable.write(await file.arrayBuffer());
                    await writable.close();
                } else if (handle.kind === 'directory') {
                    const subDir = await opfsDir.getDirectoryHandle(name, { create: true });
                    await copyDirectoryToOPFS(handle, subDir);
                }
            }
        }

        async function buildTreeFromOPFS() {
            const tree = await buildTree(opfsRoot);
            renderTree(tree);
        }

        async function buildTree(dirHandle, path = '') {
            const children = [];
            for await (const [name, handle] of dirHandle.entries()) {
                const itemPath = path ? `${path}/${name}` : name;
                if (handle.kind === 'file') {
                    children.push({ name, path: itemPath, isDir: false });
                } else if (handle.kind === 'directory') {
                    const subChildren = await buildTree(handle, itemPath);
                    children.push({ name, path: itemPath, isDir: true, children: subChildren });
                }
            }
            return children;
        }

        function renderTree(tree) {
            const ul = document.querySelector('#left-panel ul');
            ul.innerHTML = '';
            tree.forEach(item => {
                const li = document.createElement('li');
                li.className = 'p-1';
                if (item.isDir) {
                    li.innerHTML = `<span class="cursor-pointer flex items-center hover:bg-gray-200 rounded px-1 whitespace-nowrap" data-path="${item.path}" data-isdir="true" onclick="toggleDir(this)" oncontextmenu="showContextMenu(event, '${item.path}', true)">
                        <span class="toggle-icon mr-1">📁</span>
                        ${item.name}
                    </span>
                    <ul class="list-none pl-6 hidden" data-parent="${item.path}">
                        ${item.children.map(child => renderItem(child)).join('')}
                    </ul>`;
                } else {
                    li.innerHTML = `<span onclick="loadFile('${item.path}')" oncontextmenu="showContextMenu(event, '${item.path}', false)" data-path="${item.path}" data-isdir="false" class="cursor-pointer flex items-center hover:bg-gray-200 rounded px-1 whitespace-nowrap">
                        📄 ${item.name}
                    </span>`;
                }
                ul.appendChild(li);
            });
        }

        function renderItem(item) {
            if (item.isDir) {
                return `<li class="p-1">
                    <span class="cursor-pointer flex items-center hover:bg-gray-200 rounded px-1 whitespace-nowrap" data-path="${item.path}" data-isdir="true" onclick="toggleDir(this)" oncontextmenu="showContextMenu(event, '${item.path}', true)">
                        <span class="toggle-icon mr-1">📁</span>
                        ${item.name}
                    </span>
                    <ul class="list-none pl-6 hidden" data-parent="${item.path}">
                        ${item.children.map(child => renderItem(child)).join('')}
                    </ul>
                </li>`;
            } else {
                return `<li class="p-1">
                    <span onclick="loadFile('${item.path}')" oncontextmenu="showContextMenu(event, '${item.path}', false)" data-path="${item.path}" data-isdir="false" class="cursor-pointer flex items-center hover:bg-gray-200 rounded px-1 whitespace-nowrap">
                        📄 ${item.name}
                    </span>
                </li>`;
            }
        }

        async function saveFile() {
            const content = document.getElementById('editor').value;
            if (!currentFile) {
                toast('No file is open to save');
                return;
            }
            if (!opfsRoot) {
                toast('Storage not initialized');
                try { await initOPFS(); } catch {}
                if (!opfsRoot) { toast('OPFS not available in this browser'); return; }
            }
            try {
                // Ensure path exists and file is created if missing
                const fileHandle = await getFileHandle(currentFile, true, true);
                const writable = await fileHandle.createWritable();
                await writable.write(content);
                await writable.close();
                if (currentFile) {
                    fileState[currentFile] = fileState[currentFile] || {};
                    fileState[currentFile].lastSaved = content;
                    fileState[currentFile].buffer = content;
                    setDirty(currentFile, false);
                }
                // If the file wasn't in the sidebar yet (new path), rebuild the tree
                const existingSpan = findSpanByPath(currentFile);
                if (!existingSpan) {
                    const expandedBefore = getExpandedPaths();
                    await buildTreeFromOPFS();
                    restoreExpandedPaths(expandedBefore);
                }
                highlightActiveTab(currentFile);
                highlightActiveFileInTree(currentFile);
                toast(`Saved: ${currentFile}`);
            } catch (err) {
                console.error('Error saving file:', err);
                toast(`Save failed: ${String(err && err.message ? err.message : err)}. Downloading instead...`);
                // Fallback: offer download so user doesn't lose work
                downloadContentAs(currentFile || 'untitled.txt', content);
            }
        }

        async function downloadFile() {
            if (!currentFile) {
                alert('No file selected');
                return;
            }
            try {
                const fileHandle = await getFileHandle(currentFile);
                const file = await fileHandle.getFile();
                const url = URL.createObjectURL(file);
                const a = document.createElement('a');
                a.href = url;
                a.download = currentFile.split('/').pop();
                a.click();
                URL.revokeObjectURL(url);
            } catch (err) {
                console.error('Error downloading file:', err);
            }
        }

        // ===== Context menu + OPFS rename/delete =====
        let contextMenuPath = '';
        let contextMenuIsDir = false;

        function showContextMenu(event, path, isDir) {
            event.preventDefault();
            contextMenuPath = path;
            contextMenuIsDir = !!isDir;
            const menu = document.getElementById('context-menu');
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';
            menu.classList.remove('hidden');
            // Toggle New items visibility based on isDir
            document.getElementById('cm-new-file').style.display = isDir ? 'block' : 'none';
            document.getElementById('cm-new-folder').style.display = isDir ? 'block' : 'none';
        }

        function hideContextMenu() {
            document.getElementById('context-menu').classList.add('hidden');
        }

        document.addEventListener('click', () => hideContextMenu());
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hideContextMenu(); });

        // Global keyboard shortcuts
        function handleSaveShortcut(e) {
            const isSave = (e.metaKey || e.ctrlKey) && e.key && e.key.toLowerCase() === 's';
            if (!isSave) return;
            e.preventDefault();
            e.stopPropagation();
            if (currentFile) saveFile();
        }
        // Capture on multiple targets and in capture phase to override browser default
        window.addEventListener('keydown', handleSaveShortcut, { capture: true });
        document.addEventListener('keydown', handleSaveShortcut, { capture: true });
        document.body.addEventListener('keydown', handleSaveShortcut, { capture: true });
        // Also bind directly to editor textarea
        (function(){
            const ed = document.getElementById('editor');
            if (ed) ed.addEventListener('keydown', handleSaveShortcut, { capture: true });
        })();

        async function getDirectoryHandleByPath(path) {
            // path is relative to opfsRoot
            let dir = opfsRoot;
            const parts = path.split('/').filter(Boolean);
            for (const part of parts) {
                dir = await dir.getDirectoryHandle(part);
            }
            return dir;
        }

        function splitParent(path) {
            const parts = path.split('/').filter(Boolean);
            const name = parts.pop();
            const parentPath = parts.join('/');
            return { parentPath, name };
        }

        // ===== Helpers for DOM updates =====
        function cssEscapeSel(value) {
            if (window.CSS && CSS.escape) return CSS.escape(value);
            return value.replace(/"/g, '\\"');
        }

        function findSpanByPath(path) {
            const esc = cssEscapeSel(path || '');
            return document.querySelector(`[data-path="${esc}"]`);
        }

        function findChildUL(parentPath) {
            const esc = cssEscapeSel(parentPath || '');
            return document.querySelector(`ul[data-parent="${esc}"]`);
        }

        function basename(p) {
            const parts = p.split('/').filter(Boolean);
            return parts.length ? parts[parts.length - 1] : p;
        }

        function updateDirSubtreePaths(dirSpan, oldPrefix, newPrefix) {
            const ul = dirSpan.nextElementSibling;
            if (!ul || ul.tagName !== 'UL') return;
            ul.setAttribute('data-parent', newPrefix);
            const descendants = ul.querySelectorAll('[data-path]');
            descendants.forEach(el => {
                const oldPath = el.getAttribute('data-path');
                if (oldPath.startsWith(oldPrefix + '/')) {
                    const updated = newPrefix + oldPath.slice(oldPrefix.length);
                    el.setAttribute('data-path', updated);
                }
            });
        }

        async function deleteSelected() {
            hideContextMenu();
            if (!contextMenuPath) return;
            const { parentPath, name } = splitParent(contextMenuPath);
            try {
                const parent = await getDirectoryHandleByPath(parentPath);
                await parent.removeEntry(name, { recursive: contextMenuIsDir });
                // Update DOM in-place
                const span = findSpanByPath(contextMenuPath);
                if (span) {
                    const li = span.closest('li');
                    if (li && li.parentElement) li.parentElement.removeChild(li);
                }
            } catch (err) {
                console.error('Error deleting entry:', err);
                alert('Delete failed');
            }
        }

        async function renameSelected() {
            hideContextMenu();
            if (!contextMenuPath) return;
            const { parentPath, name } = splitParent(contextMenuPath);
            const newName = prompt('New name:', name);
            if (!newName || newName === name) return;
            try {
                const parent = await getDirectoryHandleByPath(parentPath);
                if (contextMenuIsDir) {
                    const srcDir = await parent.getDirectoryHandle(name);
                    const destDir = await parent.getDirectoryHandle(newName, { create: true });
                    await copyWithinOPFSDirectory(srcDir, destDir);
                    await parent.removeEntry(name, { recursive: true });
                } else {
                    const srcFile = await parent.getFileHandle(name);
                    const file = await srcFile.getFile();
                    const destFile = await parent.getFileHandle(newName, { create: true });
                    const writable = await destFile.createWritable();
                    await writable.write(await file.arrayBuffer());
                    await writable.close();
                    await parent.removeEntry(name);
                }
                // DOM update: adjust the span's label and data-path (and subtree if dir)
                const oldPath = contextMenuPath;
                const newPath = parentPath ? `${parentPath}/${newName}` : newName;
                const span = findSpanByPath(oldPath);
                if (span) {
                    span.setAttribute('data-path', newPath);
                    // Update visible name (after icon span)
                    const icon = span.querySelector('.toggle-icon');
                    if (icon && icon.nextSibling) {
                        // Replace following text (might be a text node)
                        // Simplest: set span innerHTML with preserved icon
                        if (contextMenuIsDir) icon.textContent = span.nextElementSibling ? '📁' : '📁';
                    }
                    // Better: set the text by rebuilding the innerHTML minimal
                    const nameText = ` ${newName}`;
                    if (contextMenuIsDir) {
                        span.innerHTML = `<span class="toggle-icon mr-1">📁</span>${newName}`;
                    } else {
                        span.innerHTML = `📄 ${newName}`;
                    }
                    // Restore handlers/attributes after innerHTML reset
                    span.setAttribute('data-path', newPath);
                    span.setAttribute('data-isdir', contextMenuIsDir ? 'true' : 'false');
                    if (contextMenuIsDir) {
                        span.setAttribute('onclick', 'toggleDir(this)');
                        span.setAttribute('oncontextmenu', `showContextMenu(event, '${newPath}', true)`);
                        updateDirSubtreePaths(span, oldPath, newPath);
                    } else {
                        span.setAttribute('onclick', `loadFile('${newPath}')`);
                        span.setAttribute('oncontextmenu', `showContextMenu(event, '${newPath}', false)`);
                    }
                }
            } catch (err) {
                console.error('Error renaming entry:', err);
                alert('Rename failed');
            }
        }

        async function copyWithinOPFSDirectory(srcDir, destDir) {
            for await (const [entryName, handle] of srcDir.entries()) {
                if (handle.kind === 'file') {
                    const file = await handle.getFile();
                    const destFile = await destDir.getFileHandle(entryName, { create: true });
                    const writable = await destFile.createWritable();
                    await writable.write(await file.arrayBuffer());
                    await writable.close();
                } else if (handle.kind === 'directory') {
                    const subDest = await destDir.getDirectoryHandle(entryName, { create: true });
                    await copyWithinOPFSDirectory(handle, subDest);
                }
            }
        }

        // (Removed duplicate copyDirectoryToOPFS; single definition exists earlier in file)

        async function addFolder() {
            try {
                const expandedBefore = getExpandedPaths();
                const picked = await window.showDirectoryPicker();
                // Create (or get) the destination top-level folder in OPFS
                const destTop = await opfsRoot.getDirectoryHandle(picked.name, { create: true });
                // Copy content recursively
                await copyDirectoryToOPFS(picked, destTop);
                // Refresh entire tree view after import
                await buildTreeFromOPFS();
                restoreExpandedPaths(expandedBefore);
            } catch (err) {
                if (err && err.name === 'AbortError') return; // user canceled picker
                console.error('Error adding folder:', err);
                alert('Failed to add folder');
            }
        }

        // ===== Preserve expanded folders across refresh =====
        function getExpandedPaths() {
            const paths = [];
            const spans = document.querySelectorAll('#left-panel [data-isdir="true"][data-path]');
            spans.forEach(span => {
                const ul = span.nextElementSibling;
                if (ul && ul.tagName === 'UL' && !ul.classList.contains('hidden')) {
                    const p = span.getAttribute('data-path');
                    if (p) paths.push(p);
                }
            });
            return paths;
        }

        function restoreExpandedPaths(paths) {
            if (!paths || !paths.length) return;
            paths.forEach(p => {
                const span = findSpanByPath(p);
                if (!span) return;
                const ul = span.nextElementSibling;
                if (ul && ul.tagName === 'UL') {
                    ul.classList.remove('hidden');
                    const icon = span.querySelector('.toggle-icon');
                    if (icon) icon.textContent = '📂';
                }
            });
        }

        async function newFileInContextDir() {
            hideContextMenu();
            if (!contextMenuIsDir || !contextMenuPath) return;
            const filename = prompt('New file name (e.g., note.txt):');
            if (!filename) return;
            try {
                const dir = await getDirectoryHandleByPath(contextMenuPath);
                const fileHandle = await dir.getFileHandle(filename, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write('');
                await writable.close();
                // Append to DOM under this directory if its UL exists
                const childUL = findChildUL(contextMenuPath);
                if (childUL) {
                    const item = { isDir: false, name: filename, path: (contextMenuPath ? contextMenuPath + '/' : '') + filename };
                    childUL.insertAdjacentHTML('beforeend', renderItem(item));
                }
                await loadFile((contextMenuPath ? contextMenuPath + '/' : '') + filename);
            } catch (err) {
                console.error('Error creating file:', err);
                alert('Failed to create file');
            }
        }

        async function newFolderInContextDir() {
            hideContextMenu();
            if (!contextMenuIsDir || !contextMenuPath) return;
            const folderName = prompt('New folder name:');
            if (!folderName) return;
            try {
                const dir = await getDirectoryHandleByPath(contextMenuPath);
                await dir.getDirectoryHandle(folderName, { create: true });
                const childUL = findChildUL(contextMenuPath);
                if (childUL) {
                    const item = { isDir: true, name: folderName, path: (contextMenuPath ? contextMenuPath + '/' : '') + folderName, children: [] };
                    childUL.insertAdjacentHTML('beforeend', renderItem(item));
                }
            } catch (err) {
                console.error('Error creating folder:', err);
                alert('Failed to create folder');
            }
        }

    </script>
  </body>
</html>
